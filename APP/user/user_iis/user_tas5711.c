#include "include.h"
#include "user_iis.h"
#include "user_fm.h"

u8 eq_flag;
/*const __code u8 TAS5731M_Volume_Table[VOLUME_MAX+1] ={
	255,180,140,120,110,105,100, 95, 90, 85,
	 82, 79, 76, 73, 70, 67, 64, 62, 60, 58,
	 56, 54, 52, 50, 48, 46, 44, 42, 40, 38, 
	 36, 34, 32, 
};
*/
const __code u8 TAS5731M_Volume_Table[VOLUME_MAX+1] ={
	255,160,120,100,90,85,80, 75, 70, 65,
	 61, 57, 53, 50, 47, 44, 41, 38, 35, 32,
	 29, 26, 23, 20, 17, 14, 12, 10, 8, 6, 
	 4, 2, 0, 
};


#if 0
#pragma constseg = "DSP_DATA"
const __code u8 TAS5731M_EQ_60[8] ={0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00};
const __code u8 TAS5731M_EQ_61[8] ={0x00,0x40,0x00,0x00,0x00,0x40,0x00,0x00};
const __code u8 TAS5731M_EQ_53[16]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00};
const __code u8 TAS5731M_EQ_20[20]={0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const __code u8 TAS5731M_EQ_5A[20]={0x00,0x00,0x03,0x8a,0x00,0x00,0x07,0x14,0x00,0x00,0x03,0x8a,0x00,0xFc,0x35,0x5d,0x0F,0x83,0xbc,0x79};

const __code u8 EQ1_29[20]={0x00,0x7D,0xA6,0xE3,0x0F,0x04,0xB2,0x39,0x00,0x7D,0xA6,0xE3,0x00,0xFB,0x42,0xC1,0x0F,0x84,0xA7,0x33};
const __code u8 EQ1_5B[20]={0x00,0x82,0x7b,0x30,0x0F,0x01,0xad,0xb9,0x00,0x7b,0xDa,0xa9,0x00,0xFe,0x52,0x47,0x0F,0x81,0xaa,0x27};

const __code u8 EQ1_2A[20]={0x00,0x80,0xF7,0xA6,0x0F,0x03,0x64,0xff,0x00,0x7B,0xB9,0x85,0x00,0xFC,0x9b,0x01,0x0F,0x83,0x4E,0xD4};
const __code u8 EQ1_2B[20]={0x00,0xCE,0x9B,0xD7,0x0F,0xEC,0x28,0x8E,0x0F,0xC9,0x67,0x53,0x00,0x13,0xD7,0x72,0x0F,0xE7,0xFC,0xD6};
const __code u8 EQ1_2C[20]={0x00,0x80,0xb4,0x1f,0x0F,0x05,0x9e,0xa9,0x00,0x7a,0x26,0xb7,0x00,0xfa,0x61,0x57,0x0F,0x85,0x25,0x29};
const __code u8 EQ1_2D[20]={0x00,0x80,0x97,0x27,0x0F,0x0c,0xb5,0xee,0x00,0x75,0xBB,0x45,0x00,0xf3,0x4a,0x12,0x0f,0x89,0xad,0x93};
const __code u8 EQ1_2E[20]={0x00,0x81,0xA2,0x6D,0x0F,0x2e,0x9b,0x5f,0x00,0x63,0x93,0x25,0x00,0xd1,0x64,0xa1,0x0F,0x9a,0xCa,0x6d};

const __code u8 EQ2_2B[20]={0x00,0xC7,0x06,0x46,0x0F,0xF1,0x36,0xF5,0x0F,0xAA,0x40,0x12,0x00,0x0E,0xC9,0x0B,0x00,0x0E,0xB9,0xA7};
const __code u8 EQ2_2C[20]={0x00,0x80,0x97,0xa6,0x0F,0x05,0x9e,0xa9,0x00,0x7a,0x43,0x30,0x00,0xfa,0x61,0x57,0x0F,0x85,0x25,0x29};
const __code u8 EQ2_2D[20]={0x00,0x81,0x40,0xc0,0x0F,0x0c,0xb5,0xee,0x00,0x75,0x11,0xac,0x00,0xf3,0x4a,0x12,0x0f,0x89,0xad,0x93};
const __code u8 EQ2_2E[20]={0x00,0x83,0x15,0xa3,0x0F,0x2e,0x9b,0x5f,0x00,0x62,0x1f,0xef,0x00,0xd1,0x64,0xa1,0x0F,0x9a,0xCa,0x6d};
const __code u8 EQ2_2F[20]={0x00,0x85,0x19,0x51,0x0F,0x71,0x3c,0x0c,0x00,0x44,0xcd,0x4b,0x00,0x8e,0xc3,0xf4,0x0f,0xb6,0x19,0x63};

const __code u8 EQ3_2B[20]={0x00,0x80,0xD8,0x81,0x0F,0x07,0xE6,0x2F,0x00,0x78,0x9F,0x2A,0x00,0xF8,0x19,0xD1,0x0F,0x86,0x88,0x55};
const __code u8 EQ3_2C[20]={0x00,0x81,0x77,0xF1,0x0F,0x06,0x64,0x4F,0x00,0x78,0x9C,0xDF,0x00,0xF9,0x9B,0xB1,0x0F,0x85,0xEB,0x30};
const __code u8 EQ3_2E[20]={0x00,0x80,0xCB,0x31,0x0F,0x2E,0x9B,0x5F,0x00,0x64,0x6A,0x61,0x00,0xD1,0x64,0xA1,0x0F,0x9A,0xCA,0x6D};
const __code u8 EQ3_2F[20]={0x00,0x20,0x70,0x4E,0x00,0x20,0x70,0x4E,0x00,0x00,0x00,0x00,0x00,0x3F,0x1F,0x63,0x00,0x00,0x00,0x00};

const __code u8 EQ4_60[8] ={0x00,0x00,0x00,0x00,0x00,0x4e,0x00,0xd2};
const __code u8 EQ4_61[8] ={0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00};
const __code u8 EQ4_29[20]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const __code u8 EQ4_2B[20]={0x00,0x80,0xC9,0xAF,0x03,0x02,0x1C,0x8F,0x00,0x7D,0x30,0x09,0x00,0xFD,0xE3,0x71,0x03,0x82,0x06,0x48};
const __code u8 EQ4_2C[20]={0x00,0x80,0xAA,0x86,0x03,0x05,0x9E,0xA8,0x00,0x7A,0x30,0x51,0x00,0xFA,0x61,0x58,0x03,0x85,0x25,0x29};
const __code u8 EQ4_2D[20]={0x00,0x81,0x50,0x4F,0x03,0x07,0x96,0xB0,0x00,0x7A,0x31,0xB4,0x00,0xF8,0x69,0x50,0x03,0x84,0x7D,0xFD};
const __code u8 EQ4_2E[20]={0x00,0x82,0x5C,0xE2,0x03,0x1E,0xD5,0x00,0x00,0x74,0x1D,0x3D,0x00,0xE1,0x2B,0x00,0x03,0x89,0x85,0xE2};
const __code u8 EQ4_2F[20]={0x00,0x85,0x19,0x52,0x03,0x71,0x3C,0x0C,0x00,0x44,0xCD,0x4B,0x00,0x8E,0xC3,0xF4,0x03,0xB6,0x19,0x63};
const __code u8 EQ4_58[20]={0x00,0xBC,0x0F,0x9E,0x03,0xEE,0x56,0xC9,0x03,0xCB,0x3E,0xC3,0x00,0x11,0xA9,0x37,0x03,0xF8,0xB1,0x9F};
const __code u8 EQ4_59[20]={0x00,0x7D,0x6B,0x64,0x03,0x05,0x29,0x39,0x00,0x7D,0x6B,0x64,0x00,0xFA,0xC9,0x76,0x03,0x85,0x1B,0xE8};
const __code u8 EQ4_5A[20]={0x00,0x00,0x02,0x89,0x00,0x00,0x05,0x12,0x00,0x00,0x02,0x89,0x00,0xFD,0xB7,0xE6,0x03,0x82,0x3D,0xF5};
const __code u8 EQ4_5B[20]={0x00,0x82,0x53,0x85,0x03,0x01,0x93,0x1B,0x00,0x7C,0x1C,0xF3,0x00,0xFE,0x6C,0xE5,0x03,0x81,0x8F,0x88};
const __code u8 EQ4_53[16]={0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0xa0,0x00,0x00};
const __code u8 EQ4_54[16]={0x0F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0f,0x60,0x00,0x00};
const __code u8 EQ4_55[12]={0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x0F,0xC0,0x00,0x00};
const __code u8 EQ4_5E[20]={0x00,0x7e,0x61,0x1e,0x0f,0x81,0x9e,0xe2,0x00,0x00,0x00,0x00,0x00,0x7c,0xc2,0x3c,0x00,0x00,0x00,0x00};
#endif
//1us Delay
#pragma location="DSP_IIC"
void audio_delay(void)
{
   u8 i;
   i = 10; //sys_clk = 24m
   for (; i!=0; i--) {  //SysCLK_12M //60-- 35K   //10--86k  //10
        asm("nop");
    }
}

//2us Delay
#pragma location="DSP_IIC"
void audio_delay_2(void)
{
    u8 i;
   i = 15;  //sys_clk = 24m
    for (; i!=0; i--) {
        asm("nop");
    }
}

#pragma location="DSP_IIC"
void audio_start(void)
{
    AUDIO_DATA_CLK_OUT();
    AUDIO_DATA_CLK_HIGH();
    audio_delay();
    AUDIO_DATA_LOW();
    audio_delay();
    AUDIO_CLK_LOW();
}

//结束一次IIC通信
#pragma location="DSP_IIC"
void audio_stop(void)
{
    AUDIO_DATA_OUT();
    AUDIO_DATA_LOW();
    audio_delay_2();
    AUDIO_CLK_HIGH();
    audio_delay();
    AUDIO_DATA_HIGH();
}

//IIC总线发送1byte
#pragma location="DSP_IIC"
void audio_sendbyte(u8 val)
{
    u8 i;
    AUDIO_DATA_OUT();
    for (i=8; i!=0; i--) {
        if (val & BIT(7)) {
            AUDIO_DATA_HIGH();
        } else {
            AUDIO_DATA_LOW();
        }
        audio_delay_2();
        AUDIO_CLK_HIGH();
        audio_delay();
        AUDIO_CLK_LOW();
        val <<= 1;
    }
}

//IIC总线接收1byte
#pragma location="DSP_IIC"
u8 audio_getbyte(void)
{
    u8 i;
    u8 val = 0;
    AUDIO_DATA_IN();
    for (i=8; i!=0; i--) {
        audio_delay_2();
        AUDIO_CLK_HIGH();
        audio_delay();
        val <<= 1;
        if (AUDIO_DATA_IS_HIGH()) {
            val |= BIT(0);
        }
        AUDIO_CLK_LOW();
    }
    return val;
}

//IIC总线发送ACK
#pragma location="DSP_IIC"
void audio_sendack(void)
{
    AUDIO_DATA_OUT();
    AUDIO_DATA_LOW();
    audio_delay_2();
    AUDIO_CLK_HIGH();
    audio_delay();
    AUDIO_CLK_LOW();
}

//IIC总线发送NACK
#pragma location="DSP_IIC"
void audio_sendnack(void)
{
    AUDIO_DATA_OUT();
    AUDIO_DATA_HIGH();
    audio_delay_2();
    AUDIO_CLK_HIGH();
    audio_delay();
    AUDIO_CLK_LOW();
}

//IIC总线获取ACK状态
#pragma location="DSP_IIC"
bool audio_getack(void)
{
    bool ack = false;
    AUDIO_DATA_IN();
    audio_delay_2();
    AUDIO_CLK_HIGH();
    audio_delay();
    if (!AUDIO_DATA_IS_HIGH()) {
        //printf("t\n");
        ack = true;
    }
    AUDIO_CLK_LOW();
   // printf("f\n");
    return ack;
}

#pragma location="DSP_IIC"
void tas5711_write_byte(u8 adr, u8 value)
{
  // to be filled by user API
    audio_start();                //I2C启动
#if A_SEL
    audio_sendbyte(0x36);         //写命令
#else
    audio_sendbyte(0x34);         //写命令
#endif
    audio_getack();

    audio_sendbyte(adr);   //写地址
    audio_getack();

    audio_sendbyte(value);      //写数据
    audio_getack();

    audio_stop();                 //I2C停止时序
    delay_5ms(1);
}

#pragma location="DSP_IIC"
void tas5711_write_4byte(u8 adr, u8 value0, u8 value1, u8 value2, u8 value3)
{
    // to be filled by user API
    audio_start();                //I2C启动
#if A_SEL
    audio_sendbyte(0x36);         //写命令
#else
    audio_sendbyte(0x34);         //写命令
#endif
    audio_getack();

    audio_sendbyte(adr);   //写地址
    audio_getack();

    audio_sendbyte(value0);      //写数据0
    audio_getack();

    audio_sendbyte(value1);      //写数据1
    audio_getack();

    audio_sendbyte(value2);      //写数据2
    audio_getack();

    audio_sendbyte(value3);      //写数据3
    audio_getack();

    audio_stop();                 //I2C停止时序
    delay_5ms(1);
}

#pragma location="DSP_IIC"
void tas5711_write_20byte(u8 adr, const __code u8 buffer[20], u8 len)
{
    // to be filled by user API
    u8 i;
    audio_start();                //I2C启动
#if A_SEL
    audio_sendbyte(0x36);         //写命令
#else
    audio_sendbyte(0x34);         //写命令
#endif
    audio_getack();

    audio_sendbyte(adr);   //写地址
    audio_getack();

     for(i=0;i<len;i++)
    {
        audio_sendbyte(buffer[i]);  //写数据    ////先写权小的字节
        audio_getack();
    }

    audio_stop();                 //I2C停止时序
    delay_5ms(1);
}

#pragma location="DSP_IIC"
u8 tas5711_read_byte(u8 adr)
{
    u8 I2CReadResult;

    audio_start();                //I2C启动

#if A_SEL
    audio_sendbyte(0x36);         //写命令
#else
    audio_sendbyte(0x34);         //写命令
#endif
    audio_getack();

    audio_sendbyte(adr);         //写地址
    audio_getack();

    audio_start();                    //写转为读命令，需要再次启动I2C

#if A_SEL
    audio_sendbyte(0x36 | 0x01);         //读命令
#else
    audio_sendbyte(0x34 | 0x01);         //读命令
#endif
    audio_getack();

    I2CReadResult = audio_getbyte();
    audio_sendnack();                      //发送ack命令

    audio_stop();                     //I2C停止
    delay_5ms(1);

    return I2CReadResult;
}

#pragma location="DSP_IIC"
void get_5711_err_sta(void)
{
    u8 sta = tas5711_read_byte(0x02);
    if(sta){
        tas5711_write_byte(0x02,0x00);
    }
    printf("sta = 0x%X\n",sta);

}
#if 0
#pragma location="DSP_CODE"
void TAS5731M_EQ_SETUP(void)
{
	if(eq_flag!=4)
	{
		tas5711_write_20byte(0x29,EQ1_29,20);
		tas5711_write_20byte(0x30,EQ1_29,20);
	}
	else
	{
		tas5711_write_20byte(0x29,EQ4_29,20);
		tas5711_write_20byte(0x30,EQ4_29,20);
	}

	if(eq_flag==1)
	{
		/*	  EQ mode change ------  0x29 to 0x5d	 */
		//Led_Counter = 2;
		//TAS5731M_Write_long(0x29,EQ1_29,20);
		//TAS5731M_Write_long(0x30,EQ1_29,20);
		tas5711_write_20byte(0x2A,EQ1_2A,20);
		tas5711_write_20byte(0x2B,EQ1_2B,20);
		tas5711_write_20byte(0x2C,EQ1_2C,20);
		tas5711_write_20byte(0x2D,EQ1_2D,20);
		tas5711_write_20byte(0x2E,EQ1_2E,20);
		tas5711_write_20byte(0x2F,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x58,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x59,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x31,EQ1_2A,20);
		tas5711_write_20byte(0x32,EQ1_2B,20);
		tas5711_write_20byte(0x33,EQ1_2C,20);
		tas5711_write_20byte(0x34,EQ1_2D,20);
		tas5711_write_20byte(0x35,EQ1_2E,20);
		tas5711_write_20byte(0x36,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x5C,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x5D,TAS5731M_EQ_20,20);
	}
#if 1    
	else if(eq_flag==2)
	{
		//Led_Counter = 4;
		//TAS5731M_Write_long(0x29,EQ2_29,20);
		//TAS5731M_Write_long(0x30,EQ2_29,20);
		tas5711_write_20byte(0x2A,EQ1_2A,20);
		tas5711_write_20byte(0x2B,EQ2_2B,20);
		tas5711_write_20byte(0x2C,EQ2_2C,20);
		tas5711_write_20byte(0x2D,EQ2_2D,20);
		tas5711_write_20byte(0x2E,EQ2_2E,20);
		tas5711_write_20byte(0x2F,EQ2_2F,20);
		tas5711_write_20byte(0x58,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x59,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x31,EQ1_2A,20);
		tas5711_write_20byte(0x32,EQ2_2B,20);
		tas5711_write_20byte(0x33,EQ2_2C,20);
		tas5711_write_20byte(0x34,EQ2_2D,20);
		tas5711_write_20byte(0x35,EQ2_2E,20);
		tas5711_write_20byte(0x36,EQ2_2F,20);
		tas5711_write_20byte(0x5C,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x5D,TAS5731M_EQ_20,20);
	}
	else if(eq_flag==3)
	{
		//Led_Counter = 6;
		//TAS5731M_Write_long(0x29,EQ3_29,20);
		//TAS5731M_Write_long(0x30,EQ3_29,20);
		tas5711_write_20byte(0x2A,EQ1_2A,20);
		tas5711_write_20byte(0x2B,EQ3_2B,20);
		tas5711_write_20byte(0x2C,EQ3_2C,20);
		tas5711_write_20byte(0x2D,EQ2_2D,20);
		tas5711_write_20byte(0x2E,EQ3_2E,20);
		tas5711_write_20byte(0x2F,EQ3_2F,20);
		tas5711_write_20byte(0x58,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x59,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x31,EQ1_2A,20);
		tas5711_write_20byte(0x32,EQ3_2B,20);
		tas5711_write_20byte(0x33,EQ3_2C,20);
		tas5711_write_20byte(0x34,EQ2_2D,20);
		tas5711_write_20byte(0x35,EQ3_2E,20);
		tas5711_write_20byte(0x36,EQ3_2F,20);
		tas5711_write_20byte(0x5C,TAS5731M_EQ_20,20);
		tas5711_write_20byte(0x5D,TAS5731M_EQ_20,20);
	}
	else if(eq_flag == 4)
	{
		tas5711_write_20byte(0x2A,EQ4_29,20);
		tas5711_write_20byte(0x2B,EQ4_2B,20);
		tas5711_write_20byte(0x2C,EQ4_2C,20);
		tas5711_write_20byte(0x2D,EQ4_2D,20);
		tas5711_write_20byte(0x2E,EQ4_2E,20);
		tas5711_write_20byte(0x2F,EQ4_2F,20);
		tas5711_write_20byte(0x58,EQ4_58,20);
		tas5711_write_20byte(0x59,EQ4_59,20);
		tas5711_write_20byte(0x31,EQ4_29,20);
		tas5711_write_20byte(0x32,EQ4_2B,20);
		tas5711_write_20byte(0x33,EQ4_2C,20);
		tas5711_write_20byte(0x34,EQ4_2D,20);
		tas5711_write_20byte(0x35,EQ4_2E,20);
		tas5711_write_20byte(0x36,EQ4_2F,20);
		tas5711_write_20byte(0x5C,EQ4_58,20);
		tas5711_write_20byte(0x5D,EQ4_59,20);
	}
	if(eq_flag==4)
	{		
		tas5711_write_20byte(0x5a,EQ4_5A,20);
		tas5711_write_20byte(0x5B,EQ4_5B,20);

		tas5711_write_20byte(0x60,EQ4_60,8);
		tas5711_write_20byte(0x61,EQ4_61,8);
		tas5711_write_20byte(0x53,EQ4_53,16);
		tas5711_write_20byte(0x54,EQ4_54,16);
		tas5711_write_20byte(0x55,EQ4_55,12);
		tas5711_write_20byte(0x5e,EQ4_5E,20);
	}
	else
#endif
	{
		tas5711_write_20byte(0x5a,TAS5731M_EQ_5A,20);
		tas5711_write_20byte(0x5B,EQ1_5B,20);

		tas5711_write_20byte(0x60,TAS5731M_EQ_60,8);
		tas5711_write_20byte(0x61,TAS5731M_EQ_61,8);
		tas5711_write_20byte(0x53,TAS5731M_EQ_53,16);
		tas5711_write_20byte(0x54,TAS5731M_EQ_53,16);
		tas5711_write_20byte(0x55,TAS5731M_EQ_53,12);
		tas5711_write_20byte(0x5e,TAS5731M_EQ_20,20);
	}
}
#pragma location="DSP_CODE"
void TAS5731M_EQ_Set(void)
{
    tas5711_write_byte(0x06,0xff);
    TAS5731M_EQ_SETUP();
    delay_5ms(4);
    tas5711_write_byte(0x06,0x00);
}
#pragma location="DSP_CODE"
void TAS5711_AMP_Mute_Set(u8 con)
{
    if(con)
    {
        tas5711_write_byte(0x06,0xff);
    }
    else
    {
	    tas5711_write_byte(0x06,0x00);
    }
}

#pragma location="DSP_CODE"
void TAS5711_AMP_Volume_Set(u8 volume)
{
    tas5711_write_byte(0x07,TAS5731M_Volume_Table[volume]);
}


#pragma location="DSP_CODE"
void tas5711_init(void)
{
    //printf("tas5711_init...\n");

    PDN_PIN_DIR();
    PDN_HIGH();
    delay_5ms(20);
    RST_PIN_DIR();
    RST_PIN_DIR();
    RST_LOW();
    delay_ms(1);
    RST_HIGH();
    delay_5ms(2);
    #if 0
    tas5711_write_byte(0x1B, 0x00);  //bit1: Select factory trim, autodetect of clock rates
    tas5711_write_byte(0x00, 0x60);  //fs = 44.1/48-kHz sample rate, MCLK frequency = 64 × fs
    tas5711_write_byte(0x04, 0x03);  //word length 16bit

// 默认为2.0 BTL AD MODE

// 2.0 BTL BD MODE
    tas5711_write_4byte(0x20, 0x00, 0x89, 0x77, 0x72);
    tas5711_write_byte(0x11, 0xb8);
    tas5711_write_byte(0x12, 0x60);
    tas5711_write_byte(0x13, 0xa0);
    tas5711_write_byte(0x14, 0x48);

// PBTL模式，单声道
//    tas5711_write_4byte(0x25, 0x01, 0x10, 0x32, 0x45);
//    tas5711_write_byte(0x19, 0x3a);

    tas5711_write_byte(0x06, 0x00);  //soft unmute channels
    tas5711_write_byte(0x07, 0x50);  //master volume, 0xff(soft mute), 0x30(0dB)
    tas5711_write_byte(0x05, 0x80);  //hard unmute

//    printf("%02x\n",tas5711_read_byte(0x1b));
//    get_5711_err_sta();
    #else
    tas5711_write_byte(0x1B, 0x00);  //bit1: Select factory trim, autodetect of clock rates
    tas5711_write_byte(0x00, 0x60);  //fs = 44.1/48-kHz sample rate, MCLK frequency = 64 × fs
    tas5711_write_byte(0x04, 0x03);  //word length 16bit

    tas5711_write_byte(0x06,0x3f);
    tas5711_write_byte(0x1a,0x98);
	tas5711_write_byte(0x07,0xff);
//  tas5711_write_byte(0x0a,0x30);
//  tas5711_write_byte(0x09,0x30);
//  tas5711_write_byte(0x08,0x30);
    tas5711_write_byte(0x14,0x54);
    tas5711_write_byte(0x13,0xac);
    tas5711_write_byte(0x12,0x54);
    tas5711_write_byte(0x11,0xac);
    tas5711_write_byte(0x0e,0xd1);
    
    tas5711_write_4byte(0x20, 0x00, 0x01, 0x77, 0x72);
    tas5711_write_4byte(0x21, 0x00, 0x00, 0x42, 0x03);
    
    tas5711_write_byte(0x10,0x07);
    tas5711_write_byte(0x0b,0x00);
    tas5711_write_byte(0x10,0x07);
    tas5711_write_byte(0x1c,0x02);
    tas5711_write_byte(0x19,0x30);
    
    tas5711_write_4byte(0x25, 0x01, 0x01, 0x32, 0x45);
    tas5711_write_4byte(0x50, 0x00, 0x00, 0x00, 0x00);

    /*	  EQ mode change ------  0x29 to 0x5d	 */
	TAS5731M_EQ_SETUP();

	tas5711_write_byte(0x1a,0x98);
	tas5711_write_byte(0x07,0xff);
	tas5711_write_byte(0x05,0x84);
    #endif
}
#endif
