##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   22/Jun/2016  18:27:51 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  banked                                            #
#    Data model         =  large                                             #
#    Calling convention =  extended stack reentrant                          #
#    Constant location  =  code                                              #
#    Extended stack     =  enabled                                           #
#    Dptr setup         =  1,16                                              #
#    Source file        =  E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\displa #
#                          y\lcd\lcd.c                                       #
#    Command line       =  -I "C:\Program Files\IAR Systems\Embedded         #
#                          Workbench 4.05 Evaluation version\8051\INC\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench  #
#                          4.05 Evaluation version\8051\INC\CLIB\" -I        #
#                          E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\api\   #
#                          -I E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\dis #
#                          play\ -I E:\Juchen\CW6687G\JC_M_328_20160617_P0\A #
#                          PP\display\lcd\ -I E:\Juchen\CW6687G\JC_M_328_201 #
#                          60617_P0\APP\display\lcdseg\ -I                   #
#                          E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\displa #
#                          y\led\ -I E:\Juchen\CW6687G\JC_M_328_20160617_P0\ #
#                          APP\display\ledseg\ -I E:\Juchen\CW6687G\JC_M_328 #
#                          _20160617_P0\APP\display\no\ -I                   #
#                          E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\config #
#                          \ -I E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\c #
#                          ommon\ -I E:\Juchen\CW6687G\JC_M_328_20160617_P0\ #
#                          APP\task\ -I E:\Juchen\CW6687G\JC_M_328_20160617_ #
#                          P0\APP\user\ -I E:\Juchen\CW6687G\JC_M_328_201606 #
#                          17_P0\APP\user\mp3res\ -I                         #
#                          E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\btstac #
#                          k\ -I E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\ #
#                          user\user_config\ -I E:\Juchen\CW6687G\JC_M_328_2 #
#                          0160617_P0\APP\user\user_iis\ -lC                 #
#                          E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\Debug\ #
#                          List\ -o E:\Juchen\CW6687G\JC_M_328_20160617_P0\A #
#                          PP\Debug\Obj\ -e -z9 --debug --core=plain         #
#                          --dptr=16,1 --data_model=large                    #
#                          --code_model=banked --calling_convention=ext_stac #
#                          k_reentrant --place_constants=code                #
#                          --nr_virtual_regs 20 --extended_stack             #
#                          E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\displa #
#                          y\lcd\lcd.c                                       #
#    List file          =  E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\Debug\ #
#                          List\lcd.lst                                      #
#    Object file        =  E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\Debug\ #
#                          Obj\lcd.r51                                       #
#                                                                            #
#                                                                            #
##############################################################################

E:\Juchen\CW6687G\JC_M_328_20160617_P0\APP\display\lcd\lcd.c
      1          /*****************************************************************************
      2           * Module    : Display
      3           * File      : lcd.c
      4           * Author    : Hanny
      5           * Function  : LCD驱动
      6          *****************************************************************************/
      7          #include "include.h"
      8          #if IS_LCD_DISPLAY
      9          #include "task.h"
     10          #include "task_clock.h"
     11          
     12          extern u32 calc_res_addr(u32 res_addr);         //计算资源的绝对地址
     13          extern u32 calc_charset_addr(u32 res_addr);     //计算编码表的绝对地址
     14          extern u32 calc_font_addr(u32 res_addr);        //计算字库的绝对地址
     15          extern u32 calc_word_addr(u32 res_addr);        //计算字库图片的绝对地址
     16          
     17          u32 CharacterDataAddr;    ///<unicode资源的起始地址
     18          u16 CharacterDataLength;
     19          
     20          
     21          
     22          struct {
     23              u8 mode;                //LCD的模式。包括1k的完全模式和256Byte的小缓存模式
     24          } lcd_ctl;
     25          
     26          #if THEME_SELECT==THEME_LCD_DEFAULT
     27          IAR_XDATA_A char lcd_buf1[PAGE_MAX* COLUMN_MAX] @ "LCD_BUFF1";    //屏数据的buffer
     28          IAR_XDATA_A char lcd_buf2[256] @ "LCD_BUFF2";    //屏数据的mini_buffer
     29          IAR_XDATA_A char lcd_buf3[256] @ "LCD_BUFF3";    //bt播放mp3时用的mini_buffer
     30          char *lcd_buf = lcd_buf1;
     31          #else
     32          //1K的LCD_BUFF，后512Byte同时复用于LRC_READ_BUF,f_write时的win_buf
     33          IAR_XDATA_A char lcd_buf[PAGE_MAX* COLUMN_MAX] @ "LCD_BUFF";    //屏数据的buffer
     34          #endif
     35          
     36          //设置LCD Buffer的位置。在部份情况下，需要改动这个位置
     37          #pragma location="INIT_SEG_1"
     38          void set_lcd_buf(u8 mode)
     39          {
     40              lcd_ctl.mode = mode;
     41          }
     42          
     43          /*----------------------------------------------------------------------------*/
     44          /**@brief LCD更新屏的驱动函数
     45             @param 屏更新的列位置：lcd_width, 屏更新的行位置lcd_height,
     46                   更新内容地址：lcd_buff_add, 需要更新的数据长度：len
     47             @return 无
     48             @note 每次只更新一行
     49          */
     50          /*----------------------------------------------------------------------------*/
     51          #pragma location="DISP_SEG"
     52          void lcd_update(u8 lcd_width, u8 lcd_height, u16 lcd_buff_add, u8 len)
     53          {
     54              SET_LCD_CS;
     55              if (lcd_height>=PAGE_MAX)
     56              {
     57                  return;
     58              }
     59              lcd_width += LCD_X_FIX;
     60              CLR_LCD_A0;    //LCD_COMMAND
     61              CLR_LCD_CS;
     62              asm("nop");
     63          /*
     64              SPI0BUF = 0x40;     // 从第0行开始
     65              while (!(SPI0CON & 0x80)); //等待发送完成
     66          */
     67              SPI0BUF = LCD_COLUMN_HIGH | (lcd_width >> 4);
     68              while (!(SPI0CON & 0x80)); //等待发送完成
     69              SPI0BUF = LCD_COLUMN_LOW | (lcd_width & 0x0f);
     70              while (!(SPI0CON & 0x80)); //等待发送完成
     71              SPI0BUF = LCD_PAGE_ADDR | lcd_height;
     72              while (!(SPI0CON & 0x80)); //等待发送完成
     73          
     74              SET_LCD_CS;
     75              SET_LCD_A0;
     76              asm("nop");
     77              CLR_LCD_CS;
     78          
     79              SPIDMAPTRH = (u8)((u16)lcd_buff_add >> 8);  //DMA load start address
     80              SPIDMAPTRL = (u8)((u16)lcd_buff_add);
     81              SPIDMACNT = (len/2) - 1;
     82              while (!(SPI0CON & 0x80)); //等待发送完成
     83          }
     84          
     85          /*----------------------------------------------------------------------------*/
     86          /**@brief LCD初始化命令
     87             @param [in] cmd LCD命令
     88             @return 无
     89             @note 初始化LCD屏显示时发送命令
     90          */
     91          /*----------------------------------------------------------------------------*/
     92          #pragma location="DISP_SEG"
     93          static void lcd_send_cmd(u8 cmd)
     94          {
     95              CLR_LCD_A0;    //LCD_COMMAND
     96              CLR_LCD_CS;
     97              asm("nop");
     98              SPI0BUF = cmd;
     99              while (!(SPI0CON & 0x80)); //等待发送完成
    100              SET_LCD_CS;
    101          }
    102          #pragma location="DISP_SEG"
    103          void lcd_contrast(u8 value)
    104          {
    105              if (value > 15) {
    106                  value = 15;
    107              }
    108              lcd_send_cmd(LCD_ELE_VOLUME);        //electronic Volume
    109              lcd_send_cmd(value);                   //line start
    110          }
    111          
    112          //LCD初始化
    113          #pragma location="LCD_INIT_SEG"
    114          void lcd_init(void)
    115          {
    116              u16 offset;
    117              PORT_INIT();
    118          #if (LCD_SOFT_RESET)
    119              SET_LCD_RES;
    120              delay(20);
    121              CLR_LCD_RES;
    122              delay(255);
    123              SET_LCD_RES;
    124          #endif
    125              delay(20);
    126          
    127              SPI0CON = 0x15;//0x1D;  //spi0两线模式,p0口
    128              SPIBAUD = 0x01;  //spi0波特率
    129          
    130              lcd_send_cmd(0x40);     // start line 0
    131              lcd_send_cmd(LCD_BIAS_SET | 0x00);    //lcd bias setting
    132              lcd_send_cmd(LCD_ADC_SEL | LCD_INVERT_DISPLAY);     //ADC	 invert display  //0x00 or 0x01
    133              lcd_send_cmd(LCD_COMMON_MODE & 0xc8); //common output mode //0xc0 or oxc8
    134              lcd_send_cmd(LCD_V0_RATIO | 0x06);    //Resistor Ratio
    135              lcd_contrast(sys_ctl.contrast);           //设置对比度
    136              lcd_send_cmd(LCD_POWER_MODE);         //lcd power control
    137              lcd_send_cmd(LCD_ON);
    138              draw_clear();
    139              //get CharacterDataAddr offset for font
    140              offset = spi_read16(calc_font_addr(0x4));
    141              CharacterDataAddr = calc_font_addr(offset + 0x6);
    142              //取字库长度
    143              CharacterDataLength = spi_read16(calc_font_addr(0));
    144          
    145          }
    146          
    147          //LCD初始化
    148          #pragma location="INIT_SEG"
    149          void lcd_quick_init(void)
    150          {
    151              u16 offset;
    152              PORT_INIT();
    153          
    154              SPI0CON = 0x15;//0x1D;  //spi0两线模式,p0口
    155              SPIBAUD = 0x01;  //spi0波特率
    156          
    157              offset = spi_read16(calc_font_addr(0x4));
    158              CharacterDataAddr = calc_font_addr(offset + 0x6);
    159              //取字库长度
    160              CharacterDataLength = spi_read16(calc_font_addr(0));
    161          }
    162          
    163          /*----------------------------------------------------------------------------*/
    164          /**@brief 转换GBK的编码到unicode 的编码。
    165             @param [in] gb ：字符的GBK编码。
    166             @return 无
    167             @note ConvertGBKtoUTF16
    168          */
    169          /*----------------------------------------------------------------------------*/
    170          #pragma location="FONT_SEG"
    171          u16 ConvertGBKtoUTF16(u16 gb)
    172          {
    173              u32 index;
    174              FontTable FontTabHead;
    175              u32 CharacterAddr;
    176              u16 offset = 0;
    177              if(gb<256)
    178                  return gb;
    179          
    180              do {
    181                  spi_read(&FontTabHead, calc_charset_addr(offset), sizeof(FontTable));
    182                  FontTabHead.sign = swap_u16(FontTabHead.sign);
    183                  FontTabHead.lang_id = swap_u16(FontTabHead.lang_id);
    184                  FontTabHead.address = swap_u32(FontTabHead.address);
    185                  if(FontTabHead.sign != 0xFEFE) {
    186                      break;
    187                  }
    188                  CharacterAddr = calc_charset_addr(FontTabHead.address);
    189                  offset += sizeof(FontTable);
    190              } while(FontTabHead.lang_id != 0);
    191          #if 1
    192          //GBK
    193              index=(BYTE1(gb) - 0x81) * 0xbf + (BYTE0(gb) - 0x40);
    194          #else
    195          //GB2312
    196              if(BYTE1(gb) <= 0xa9) {
    197          	    index = (BYTE1(gb) - 0xa1) * 0x5e + (BYTE0(gb) - 0xa1);
    198              } else {
    199          	    index = (BYTE1(gb) - 0xb0 + 9) * 0x5e + (BYTE0(gb) - 0xa1);
    200          	}
    201          #endif
    202              return spi_read16(index*2+CharacterAddr);
    203          }
    204          
    205          /*----------------------------------------------------------------------------*/
    206          /**@brief   获取字的字库
    207             @param [in] utf16:  字的unicode编码;data : 字符的显示数据;length: data 的长度。
    208             @return   >0 ：数据的长度。  =0 ：没有找到字库
    209             @note GetCharacterData
    210          */
    211          /*----------------------------------------------------------------------------*/
    212          #pragma location="FONT_SEG"
    213          u32 get_unicode_addr(u16 index)
    214          {
    215              FontSegment FirstFont;
    216              u16 low, mid, high;
    217              low = 1;
    218              high = CharacterDataLength;
    219              while (1) {
    220                  mid = (low + high) / 2;
    221                  spi_read(&FirstFont, CharacterDataAddr + (mid - 1) * sizeof(FontSegment), sizeof(FontSegment));
    222          
    223                  if (index < FirstFont.StartVaule) {
    224                      high = mid -1;
    225                  } else if (index > FirstFont.EndVaule) {
    226                      low = mid + 1;
    227                  } else {
    228                      break;
    229                  }
    230          
    231                  if(low > high) {
    232                      //找不到编码，使用'□'。这个是一定找得到的
    233                      index = 0x25a1;
    234                      low = 1;                        //重新开始查找
    235                      high = CharacterDataLength;
    236                  }
    237              }
    238          
    239              return ((u32)(index - FirstFont.StartVaule) * FRONT_STRUCT + FirstFont.startaddress + CharacterDataAddr);
    240          }
    241          
    242          //获取当前字符的宽度。如果是全角，则需要2个字符
    243          u8 get_char_width(char ch)
    244          {
    245              if (ch & 0x80) {
    246                  return 12;              //全角字符的宽度
    247              }
    248              return spi_read8(get_unicode_addr(ch));
    249          }
    250          
    251          
    252          #if SLIDER_EN
    253          //显示一个文字
    254          #pragma location="FONT_SEG"
    255          u8 get_char_data(char *disp_buf, u16 code, s16 x, u8 mode,u8 slider_width)
    256          {
    257              u8 line, w;
    258              u8 font_w;
    259              u32 font_addr;
    260              u8 half_mode = (mode & TX_HALF);
    261          
    262              font_addr = get_unicode_addr(code);
    263          
    264              font_w = spi_read8(font_addr);
    265              if (font_w > CHAR_WIDTH_MAX) {
    266                  font_w = CHAR_WIDTH_MAX;
    267              }
    268              font_addr = CharacterDataAddr + spi_read32(font_addr + 4);
    269          
    270              w = font_w;
    271          
    272              if ((x + font_w) > (COLUMN_MAX-slider_width)) {
    273                  w = half_mode ? ((COLUMN_MAX-slider_width) - x) : 0;        //确定是否拷贝行末的半个字
    274              }
    275              if (w == 0) {
    276                  return 0;                               //已经结束
    277              }
    278              if (x < 0) {
    279                  if (half_mode && x + font_w > 0) {
    280                      w = half_mode ? (x + font_w) : 0;        //确定是否拷贝行前的半个字
    281                      font_addr -= x;                     //x为负数，即往后偏移x的绝对值
    282                      x = 0;
    283                  }
    284              }
    285              if (x >= 0) {
    286                  disp_buf += x;
    287                  for(line=0; line!=2; line++) {
    288                      spi_read(disp_buf, font_addr, w);
    289                      disp_buf += COLUMN_MAX;
    290                      font_addr += font_w;
    291                  }
    292              }
    293              return font_w;
    294          }
    295          //输出Unicode字符
    296          #pragma location="FONT_SEG"
    297          char *disp_put_unicode(char *disp_buf, char *str, s16 x, u8 mode,u8 slider_width)
    298          {
    299              u8 w;
    300          
    301              while ((*str || *(str+1)) && x < (COLUMN_MAX-slider_width)) {
    302                  w = get_char_data(disp_buf, *((u16 *)str), x, mode,slider_width);
    303                  if(w == 0) {
    304                      break;
    305                  }
    306                  x += w;
    307                  str += 2;
    308              }
    309              return str;
    310          }
    311          
    312          //输出GBK字符
    313          #pragma location="FONT_SEG"
    314          char *disp_put_gbk(char * disp_buf, char * str, s16 x, u8 mode,u8 slider_width)
    315          {
    316              u16 code = 0;
    317              u8 w;
    318              u8 ch_len;
    319              u8 center_flag = 0;
    320              if (x == TX_CENTER) {
    321                  x = 0;
    322                  center_flag = 1;
    323              }
    324              while (*str && x < (COLUMN_MAX-slider_width)) {
    325                  if (*str & 0x80) {
    326                      code = str[1] | (str[0] << 8);  //高位在前
    327                      ch_len = 2;
    328                  } else  {
    329                      code = *str;
    330                      ch_len = 1;
    331                  }
    332                  if (code >= 256) {
    333                      //printf("gbk=%04x\n", code);
    334                      //code = 0xb0a1;
    335                      code=ConvertGBKtoUTF16(code);
    336                      //printf("gbk=%04x\n", code);
    337                  }
    338                  w = get_char_data(disp_buf, code, x, mode,slider_width);
    339                  if (w == 0) {
    340                      break;
    341                  }
    342                  x += w;
    343                  str += ch_len;
    344              }
    345              //居中处理
    346              if (center_flag && x < (COLUMN_MAX-slider_width)) {
    347                  char *src_buf = disp_buf + x - 1;
    348                  w = ((COLUMN_MAX-slider_width) - x) / 2;
    349                  char *des_buf = src_buf + w;
    350                  while (x--) {
    351                      *des_buf = *src_buf;
    352                      *(des_buf + (COLUMN_MAX-slider_width)) = *(src_buf + (COLUMN_MAX-slider_width));
    353                      des_buf--;
    354                      src_buf--;
    355                  }
    356                  while (w--) {
    357                      *des_buf = 0;
    358                      *(des_buf +(COLUMN_MAX-slider_width)) = 0;
    359                      des_buf--;
    360                  }
    361              }
    362              return str;
    363          }
    364          
    365          
    366          #else
    367          //显示一个文字
    368          #pragma location="FONT_SEG"
    369          u8 get_char_data(char *disp_buf, u16 code, s16 x, u8 mode)
    370          {
    371              u8 line, w;
    372              u8 font_w;
    373              u32 font_addr;
    374              u8 half_mode = (mode & TX_HALF);
    375          
    376              font_addr = get_unicode_addr(code);
    377          
    378              font_w = spi_read8(font_addr);
    379              if (font_w > CHAR_WIDTH_MAX) {
    380                  font_w = CHAR_WIDTH_MAX;
    381              }
    382              font_addr = CharacterDataAddr + spi_read32(font_addr + 4);
    383          
    384              w = font_w;
    385          
    386              if ((x + font_w) > COLUMN_MAX) {
    387                  w = half_mode ? (COLUMN_MAX - x) : 0;        //确定是否拷贝行末的半个字
    388              }
    389              if (w == 0) {
    390                  return 0;                               //已经结束
    391              }
    392              if (x < 0) {
    393                  if (half_mode && x + font_w > 0) {
    394                      w = half_mode ? (x + font_w) : 0;        //确定是否拷贝行前的半个字
    395                      font_addr -= x;                     //x为负数，即往后偏移x的绝对值
    396                      x = 0;
    397                  }
    398              }
    399              if (x >= 0) {
    400                  disp_buf += x;
    401                  for(line=0; line!=2; line++) {
    402                      spi_read(disp_buf, font_addr, w);
    403                      disp_buf += COLUMN_MAX;
    404                      font_addr += font_w;
    405                  }
    406              }
    407              return font_w;
    408          }
    409          
    410          //输出Unicode字符
    411          #pragma location="FONT_SEG"
    412          char *disp_put_unicode(char *disp_buf, char *str, s16 x, u8 mode)
    413          {
    414              u8 w;
    415          
    416              while ((*str || *(str+1)) && x < COLUMN_MAX) {
    417                  w = get_char_data(disp_buf, *((u16 *)str), x, mode);
    418                  if(w == 0) {
    419                      break;
    420                  }
    421                  x += w;
    422                  str += 2;
    423              }
    424              return str;
    425          }
    426          
    427          //输出GBK字符
    428          #pragma location="FONT_SEG"
    429          char *disp_put_gbk(char *disp_buf, char *str, s16 x, u8 mode)
    430          {
    431              u16 code = 0;
    432              u8 w;
    433              u8 ch_len;
    434              u8 center_flag = 0;
    435              if (x == TX_CENTER) {
    436                  x = 0;
    437                  center_flag = 1;
    438              }
    439              while (*str && x < COLUMN_MAX) {
    440                  if (*str & 0x80) {
    441                      code = str[1] | (str[0] << 8);  //高位在前
    442                      ch_len = 2;
    443                  } else  {
    444                      code = *str;
    445                      ch_len = 1;
    446                  }
    447                  if (code >= 256) {
    448                      //printf("gbk=%04x\n", code);
    449                      //code = 0xb0a1;
    450                      code=ConvertGBKtoUTF16(code);
    451                      //printf("gbk=%04x\n", code);
    452                  }
    453                  w = get_char_data(disp_buf, code, x, mode);
    454                  if (w == 0) {
    455                      break;
    456                  }
    457                  x += w;
    458                  str += ch_len;
    459              }
    460              //居中处理
    461              if (center_flag && x < COLUMN_MAX) {
    462                  char *src_buf = disp_buf + x - 1;
    463                  w = (COLUMN_MAX - x) / 2;
    464                  char *des_buf = src_buf + w;
    465                  while (x--) {
    466                      *des_buf = *src_buf;
    467                      *(des_buf + COLUMN_MAX) = *(src_buf + COLUMN_MAX);
    468                      des_buf--;
    469                      src_buf--;
    470                  }
    471                  while (w--) {
    472                      *des_buf = 0;
    473                      *(des_buf + COLUMN_MAX) = 0;
    474                      des_buf--;
    475                  }
    476              }
    477              return str;
    478          }
    479          #endif
    480          //区域取反
    481          #pragma location="DISP_SEG"
    482          void disp_invert(u8 x, u8 line, u8 width, u8 line_cnt)
    483          {
    484              u8 i, j;
    485              char *disp_ptr;
    486              if (lcd_ctl.mode != LCD_FULL_MODE) {
    487                  //非完全模式下，进行修整
    488                  if (line >= 2) {
    489                      return;
    490                  }
    491                  if (line + line_cnt >= 2) {
    492                      line_cnt = 2 - line;
    493                  }
    494              }
    495              if (x+width > COLUMN_MAX || line+line_cnt > PAGE_MAX) {
    496                  return;
    497              }
    498          
    499              for (i=0; i!=line_cnt; i++) {
    500                  disp_ptr = &lcd_buf[(COLUMN_MAX * (line + i)) + x];
    501                  for (j=0; j!=width; j++) {
    502                      *disp_ptr = ~*disp_ptr;
    503                      disp_ptr++;
    504                  }
    505              }
    506          }
    507          
    508          //清空
    509          #pragma location="DRAW_IMG_SEG"
    510          void disp_clear(void)
    511          {
    512              u16 disp_buf_len = 1024;
    513              if (lcd_ctl.mode != LCD_FULL_MODE) {
    514                  disp_buf_len = 256;                   //仅完全模式支持
    515              }
    516              memset(lcd_buf, 0, disp_buf_len);
    517          }
    518          
    519          //清空
    520          #pragma location="DISP_SEG"
    521          void line_clear(void)
    522          {
    523              memset(lcd_buf, 0, 256);
    524          }
    525          
    526          
    527          //画字函数
    528          //mode=0，不显示半字；mode=1，显示半字
    529          #pragma location="DRAW_TEXT_SEG"
    530          char *disp_text(char *str, s16 x, u8 line, u8 mode)
    531          {
    532              if (lcd_ctl.mode != LCD_FULL_MODE) {
    533                  if (line != 0) {
    534                      return 0;                             //仅完全模式支持
    535                  }
    536              }
    537          #if SLIDER_EN
    538              return disp_put_gbk(&lcd_buf[COLUMN_MAX*line], str, x, mode,0);
    539          #else
    540              return disp_put_gbk(&lcd_buf[COLUMN_MAX*line], str, x, mode);
    541          #endif
    542          }
    543          
    544          //画字函数
    545          //mode=0，不显示半字；mode=1，显示半字
    546          #pragma location="DRAW_TEXT_SEG"
    547          char *disp_text_u(char *str, s16 x, u8 line, u8 mode)
    548          {
    549              if (lcd_ctl.mode != LCD_FULL_MODE) {
    550                  if (line != 0) {
    551                      return 0;                             //仅完全模式支持
    552                  }
    553              }
    554          #if SLIDER_EN
    555              return disp_put_unicode(&lcd_buf[COLUMN_MAX*line], str, x, mode,0);
    556          #else
    557              return disp_put_unicode(&lcd_buf[COLUMN_MAX*line], str, x, mode);
    558          #endif
    559          }
    560          
    561          #if SLIDER_EN
    562          //画字函数
    563          //mode=0，不显示半字；mode=1，显示半字   //界面右边显示滚动条
    564          #pragma location="DRAW_TEXT_SEG"
    565          char *disp_addslider_text(char *str, s16 x, u8 line, u8 mode)
    566          {
    567              if (lcd_ctl.mode != LCD_FULL_MODE) {
    568                  if (line != 0) {
    569                      return 0;                             //仅完全模式支持
    570                  }
    571              }
    572              return disp_put_gbk(&lcd_buf[COLUMN_MAX*line], str, x, mode,6);
    573          }
    574          
    575          //画字函数
    576          //mode=0，不显示半字；mode=1，显示半字
    577          #pragma location="DRAW_TEXT_SEG"
    578          char *disp_addsleder_text_u(char *str, s16 x, u8 line, u8 mode)
    579          {
    580              if (lcd_ctl.mode != LCD_FULL_MODE) {
    581                  if (line != 0) {
    582                      return 0;                             //仅完全模式支持
    583                  }
    584              }
    585              return disp_put_unicode(&lcd_buf[COLUMN_MAX*line], str, x, mode,6);
    586          }
    587          #endif
    588          
    589          
    590          //画图函数
    591          #pragma location="DRAW_IMG_SEG"
    592          void disp_draw(u16 imageindex, u8 x, u8 line)
    593          {
    594              u32 res_addr;
    595              u8 icon_width, icon_line;                   //宽高应该都在256以内
    596              u32 icon_addr;
    597          //    u16 icon_length;                            //大小最大为128x64 = 8192
    598              u8 i;
    599              char *disp_ptr;
    600          
    601              res_addr = calc_res_addr(imageindex * ICON_FILE_HEAD + 4);
    602          
    603              icon_width = spi_read16(res_addr);          //宽
    604              icon_line = spi_read16(res_addr+2) >> 3;    //行
    605              icon_addr = spi_read32(res_addr+8);         //资源起始
    606          
    607          //    icon_length = spi_read32(res_addr+12);      //资源长度
    608             // printf("%u: w=%u; h=%u; addr=%04lx\n", imageindex, icon_width, icon_line, icon_addr);
    609          
    610              if (lcd_ctl.mode != LCD_FULL_MODE) {
    611                  if (line >= 2) {
    612                      return;                             //仅完全模式支持
    613                  }
    614                  if (line + icon_line >= 2) {
    615                      icon_line = 2 - line;
    616                  }
    617              }
    618              if (icon_line > 8) {
    619                  return;
    620              }
    621          
    622              icon_addr = calc_res_addr(icon_addr);
    623              disp_ptr = &lcd_buf[x + COLUMN_MAX*line];
    624              for (i=0; i!=icon_line; i++) {
    625                  spi_read(disp_ptr, icon_addr, icon_width);
    626                  icon_addr += icon_width;
    627                  disp_ptr += COLUMN_MAX;
    628              }
    629          }
    630          
    631          //写数字的函数。默认为左对齐
    632          #pragma location="DRAW_IMG_SEG"
    633          void disp_num(u16 num, u8 x, u8 line, u8 mode)
    634          {
    635              u16 i;
    636              u8 n;
    637              u16 bound = 1;
    638              u8 wid = 7;
    639              u8 right = 0;       //右对齐
    640              u8 fill = 0;        //左边填充0
    641              u8 bound_bit = mode & DN_BOUND_MASK;    //数字最大位数
    642              u16 res_index = RES_MEDIUMNUM_0_BMP;
    643              if (lcd_ctl.mode != LCD_FULL_MODE) {
    644                  if (line >= 2) {
    645                      return;                             //仅完全模式支持
    646                  }
    647              }
    648              if (bound_bit == 0 || bound_bit > 4) {
    649                  bound_bit = 4;
    650              }
    651              while (bound_bit--) {
    652                  bound *= 10;                //计算数值区域
    653              }
    654              if (mode & DN_RIGHT) {
    655                  right = 1;                  //右对齐
    656                  if (mode & DN_ZERO) {
    657                      fill = 1;               //右对齐，并填充0
    658                  }
    659              }
    660              if (mode & DN_SMALL) {
    661                  res_index = RES_SMALLNUM_0_BMP;
    662              } else if (mode & DN_BIG) {
    663                  res_index = RES_BIGNUM_0_BMP;
    664                  wid = 15;
    665              } else if (mode & DN_SSMALL) {
    666                  wid = 6;
    667                  res_index = RES_SMALLNUM_SS0_BMP;
    668              }
    669          
    670              if (num >= bound) {             //限定最大值
    671                  num = bound - 1;
    672              }
    673              for (i=bound/10; i>=1; i/=10) {
    674                  n = num / i;
    675                  if (n || fill || (i==1)) {              //当有值、填0、左对齐、个位时，一定显示
    676                      disp_draw(res_index+n, x, line);
    677                      fill = 1;                           //出现过数据，则一定需要填充数据，包括0
    678                      x += wid;
    679                  } else if (!fill && right) {            //右对齐不填充
    680                      x += wid;
    681                  }
    682                  num %= i;
    683              }
    684          }
    685          
    686          //显示中格式时间。。分秒
    687          #pragma location="DRAW_IMG_SEG"
    688          void disp_medium_time1(u8 min, u8 sec, u8 x, u8 line)
    689          {
    690              if (lcd_ctl.mode != LCD_FULL_MODE) {
    691                  if (line >= 2) {
    692                      return;                             //仅完全模式支持
    693                  }
    694              }
    695              disp_num(min, x, line, DN_RIGHT | DN_ZERO | 2);
    696              disp_draw(RES_MEDIUMNUM_COLON_BMP, x + 18, line);
    697              disp_num(sec, x + 23, line, DN_RIGHT | DN_ZERO | 2);
    698          }
    699          
    700          //显示小格式时间。总宽度为 7*2 + 5 + 7*2 = 33
    701          #pragma location="DRAW_IMG_SEG"
    702          void disp_small_time(u8 min, u8 sec, u8 x, u8 line)
    703          {
    704              if (lcd_ctl.mode != LCD_FULL_MODE) {
    705                  if (line >= 2) {
    706                      return;                             //仅完全模式支持
    707                  }
    708              }
    709              disp_num(min, x, line, DN_RIGHT | DN_ZERO | DN_SMALL | 2);
    710              disp_draw(RES_SMALLNUM_COLON_BMP, x + 14, line);
    711              disp_num(sec, x + 19, line, DN_RIGHT | DN_ZERO | DN_SMALL | 2);
    712          }
    713          
    714          //显示中格式时间。总宽度为
    715          #pragma location="DRAW_IMG_SEG"
    716          void disp_medium_time(u8 hour, u8 min, u8 sec, u8 x, u8 line)
    717          {
    718              if (lcd_ctl.mode != LCD_FULL_MODE) {
    719                  if (line >= 2) {
    720                      return;                             //仅完全模式支持
    721                  }
    722              }
    723              disp_num(hour, x, line, DN_RIGHT | DN_ZERO | 2);
    724              disp_draw(RES_MEDIUMNUM_COLON_BMP, x + 18, line);
    725              disp_num(min, x + 23, line, DN_RIGHT | DN_ZERO | 2);
    726              disp_draw(RES_MEDIUMNUM_COLON_BMP, x + 41, line);
    727              disp_num(sec, x + 46, line, DN_RIGHT | DN_ZERO | 2);
    728          }
    729          
    730          
    731          
    732          //显示进度条
    733          void progressbar(u8 percent, u8 line)
    734          {
    735              if (lcd_ctl.mode != LCD_FULL_MODE) {
    736                  if (line >= 2) {
    737                      return;                             //仅完全模式支持
    738                  }
    739              }
    740              u8 x = 29 + (percent * 65 >> 7);
    741              disp_draw(RES_OCX_BAR_BMP, 29, line);
    742              disp_draw(RES_OCX_INDEX_BMP, x, line);
    743          }
    744          
    745          //SPI更新显示
    746          #pragma location="DISP_SEG"
    747          void disp_update(void)
    748          {
    749              u8 i;
    750              char *line_ptr = lcd_buf;
    751              if (lcd_ctl.mode != LCD_FULL_MODE) {
    752                  return;                             //仅完全模式支持
    753              }
    754              for (i=0; i!=PAGE_MAX; i++) {
    755                  lcd_update(0, i, (u16)line_ptr, COLUMN_MAX);
    756                  line_ptr += COLUMN_MAX;
    757              }
    758          }
    759          
    760          //SPI按行更新显示，一次更新两行。
    761          #pragma location="DISP_SEG"
    762          void line_update(u8 line)
    763          {
    764              u8 i;
    765              char *line_ptr = lcd_buf;
    766              if (line >= PAGE_MAX-1) {
    767                  return;
    768              }
    769              for (i=0; i!=2; i++) {
    770                  lcd_update(0, i + line, (u16)line_ptr, COLUMN_MAX);
    771                  line_ptr += COLUMN_MAX;
    772              }
    773          }
    774          
    775          //SPI按行更新并清空
    776          #pragma location="DISP_SEG"
    777          void line_update_clear(u8 line)
    778          {
    779              line_update(line);
    780              line_clear();
    781          }
    782          //按行直接清空屏显
    783          #pragma location="DRAW_IMG_SEG1"
    784          
    785          void draw_clear(void)
    786          {
    787              u8 i;
    788              memset(lcd_buf, 0, COLUMN_MAX);
    789              for (i=0; i!=8; i++) {
    790                  lcd_update(0, i, (u16)lcd_buf, COLUMN_MAX);
    791              }
    792          }
    793          
    794          //快速直接画图函数。要求图像宽度小于256Byte
    795          #pragma location="DRAW_IMG_SEG"
    796          void draw_img(u16 imageindex, u8 x, u8 line)
    797          {
    798              u32 res_addr;
    799              u8 icon_width, icon_line;                 //宽高应该都在256以内
    800              u32 icon_addr;
    801              u8 i;
    802          
    803              res_addr = calc_res_addr(imageindex * ICON_FILE_HEAD + 4);
    804          
    805              icon_width = spi_read16(res_addr);          //宽
    806              icon_line = spi_read16(res_addr+2) >> 3;    //行
    807              icon_addr = calc_res_addr(spi_read32(res_addr+8));         //资源起始
    808          
    809          //    icon_length = spi_read32(res_addr+12);      //资源长度
    810          //    printf("%u: w=%u; h=%u; addr=%04lx\n", imageindex, icon_width, icon_height, icon_addr);
    811              for (i=0; i!=icon_line; i++) {
    812                  spi_read(lcd_buf, icon_addr, icon_width);
    813                  lcd_update(x, i + line, (u16)lcd_buf, icon_width);
    814                  icon_addr += icon_width;
    815              }
    816          }
    817          
    818          //等待界面
    819          #pragma location="DRAW_IMG_SEG1"
    820          void draw_wait(void)
    821          {
    822              u8 i;
    823              line_clear();
    824              for (i=0; i!=3; i++) {
    825                  lcd_update(0, i, (u16)lcd_buf, COLUMN_MAX);
    826              }
    827              for (i=5; i!=8; i++) {
    828                  lcd_update(0, i, (u16)lcd_buf, COLUMN_MAX);
    829              }
    830             // disp_llp_text(llp_waiting, TX_CENTER, 0, 0);
    831              disp_menu(STR_WAITING, 0, 0, 0, ME_CENTER);
    832              line_update(3);
    833          }
    834          
    835          //同步联系人等待界面
    836          #pragma location="DRAW_IMG_SEG1"
    837          void sync_contacts_wait(void)
    838          {
    839              u8 i;
    840              line_clear();
    841              for (i=0; i!=3; i++) {
    842                  lcd_update(0, i, (u16)lcd_buf, COLUMN_MAX);
    843              }
    844              for (i=5; i!=8; i++) {
    845                  lcd_update(0, i, (u16)lcd_buf, COLUMN_MAX);
    846              }
    847              disp_menu(STR_BT_SYNC_WAITING, 0, 0, 0, ME_CENTER);
    848              line_update(3);
    849          }
    850          
    851          //获取语言种数
    852          #pragma location="DRAW_IMG_SEG1"
    853          void disp_language_numget(void)
    854          {
    855              u32 res_addr;
    856              res_addr = calc_word_addr(0);
    857              sys_ctl.lang_num = spi_read16(res_addr+12);
    858          }
    859          
    860          //画菜单文字函数
    861          #pragma location="DRAW_IMG_SEG"
    862          void disp_menu(u16 menuindex, u8 x, s16 mov_x, u8 line, u8 mode)
    863          {
    864              u32 res_addr;
    865              u8 icon_width,icon_width1;
    866              //u16 icon_line;                   //宽高应该都在256以内
    867              u32 icon_addr;
    868              //    u16 icon_length;                            //大小最大为128x64 = 8192
    869              u8 i;
    870              char *disp_ptr;
    871          
    872              u8 lines_flag = 1;
    873              u8 read_width; //应该读取的宽度
    874              //printf("%02x\n",menuindex);
    875              menuindex = menuindex*sys_ctl.lang_num + sys_ctl.lang_id;
    876              res_addr = calc_word_addr(menuindex * ICON_FILE_HEAD);
    877              // printf("icon_add%ld\n",res_addr);
    878              icon_width = spi_read8(res_addr);          //宽
    879              icon_width1 = spi_read8(res_addr+13);       //是否有两行
    880              if(icon_width1)
    881              {
    882                  icon_width1 = spi_read8(res_addr+8);   //第二行宽度
    883              }
    884              move_ctl.name_wide1 = icon_width + icon_width1;
    885              read_width = icon_width;
    886              //icon_line = spi_read16(res_addr+2)>> 3;    //行
    887             // printf("line%d\n",icon_line);
    888              //printf("w:%d,w1:%d\n",icon_width,icon_width1);
    889              icon_addr = spi_read32(res_addr+4);         //资源起始
    890              icon_addr = calc_word_addr(icon_addr);
    891              if (lcd_ctl.mode == LCD_FULL_MODE)
    892              {
    893                  disp_ptr = &lcd_buf[x + COLUMN_MAX*line];
    894              }
    895              else
    896              {
    897                  disp_ptr =  &lcd_buf[x];
    898              }
    899              if(mode & ME_CENTER)
    900              {
    901                  disp_ptr -= x;
    902                  x = COLUMN_MAX - icon_width;
    903                  x >>=1;
    904                  disp_ptr += x;
    905              }
    906              if(mov_x<0)
    907              {
    908                  icon_addr = icon_addr - mov_x;
    909                  read_width = icon_width + mov_x;
    910              }
    911              if (read_width + x > COLUMN_MAX)
    912              {
    913                  read_width = COLUMN_MAX - x;
    914                  lines_flag = 0;
    915              }
    916              //printf("w:%d,w1:%d\n",read_width,icon_width1);
    917              for (i=0; i!=2; i++) {
    918                  spi_read(disp_ptr, icon_addr, read_width);
    919                  icon_addr += icon_width;
    920                  disp_ptr += COLUMN_MAX;
    921              }
    922              if(mode & ME_MSG)
    923                  line_update_clear(2);
    924              if(!lines_flag)
    925                  return;
    926              if(icon_width1)
    927              {
    928                  if(mode & ME_LINES)
    929                  {
    930                      //line_update_clear(2);
    931                      disp_ptr =  &lcd_buf[x];
    932                      read_width = icon_width1;
    933                  }
    934                  else
    935                  {
    936                      if(mov_x<0)
    937                      {
    938                          icon_addr += mov_x;
    939                      }
    940                      disp_ptr = &lcd_buf[x] + read_width ;
    941                      read_width = COLUMN_MAX - read_width - x;
    942                      /*两行之间留点空隙*/
    943                      if(read_width >= 6)
    944                      {
    945                          read_width -= 6;
    946                          disp_ptr += 6;
    947                      }
    948                      else
    949                      {
    950                          read_width = 0;
    951                          return;
    952                      }
    953                      if(icon_width1 < read_width)
    954                          read_width = icon_width1;
    955                  }
    956                  for (i=0; i!=2; i++) {
    957                      spi_read(disp_ptr, icon_addr, read_width);
    958                      icon_addr += icon_width1;
    959                      disp_ptr += COLUMN_MAX;
    960                  }
    961              }
    962          }
    963          
    964          #define show_time_display_hour_min_sec()    make_time(irtcc_read_rtc(READ_RTC));\
    965                                                      disp_num(t_time.hour, 6, 2, DN_BIG | DN_RIGHT | DN_ZERO | 2);\
    966                                                      disp_draw(RES_BIGNUM_COLON_BMP, 6+28+1, 2);\
    967                                                      disp_num(t_time.minute, 6+28+1+12+1, 2, DN_BIG| DN_RIGHT | DN_ZERO | 2);\
    968                                                      disp_draw(RES_BIGNUM_COLON_BMP, 6+28+1+12+1+28+1, 2);\
    969                                                      disp_num(t_time.second, 6+28+1+12+1+28+1+12+1, 2, DN_BIG| DN_RIGHT | DN_ZERO | 2)
    970          
    971          #pragma location="TASK_CLOCK_SEG"
    972          void clock_show(void)
    973          {
    974              u32 rtc_time = irtcc_read_rtc(READ_RTC);
    975          
    976              if (t_clock.disp_rtc != rtc_time) {
    977                  t_clock.disp_rtc = rtc_time;
    978                  t_clock.disp_flag = 1;
    979              }
    980              if (sys_ctl.bat_val != sys_ctl.disp_bat_val) {
    981                  sys_ctl.disp_bat_val = sys_ctl.bat_val;
    982                  t_clock.disp_flag = 1;             //设置更新标志
    983              }
    984              if (!t_clock.disp_flag) {
    985                  return;
    986              }
    987              t_clock.disp_flag = 0;
    988          
    989              //disp_clear();
    990              memset(lcd_buf+128, 0, 1024-128);
    991          
    992              show_time_display_hour_min_sec();
    993          
    994              if (sys_ctl.bat_val >= 1) {
    995                  disp_draw(RES_ICON_BAT0_BMP + sys_ctl.bat_val - 1, 108, 0);
    996              }
    997              if(sys_ctl.alarm_switch)
    998              {
    999                  disp_draw(RES_MAIN_RTC0_BMP, 60, 0);
   1000              }
   1001          #if FM_TIME_EN
   1002              if(sys_ctl.time_fm_on)
   1003              {
   1004                  disp_draw(RES_MAIN_RADIO0_BMP, 80, 0);
   1005              }
   1006          #endif
   1007              disp_update();
   1008          }
   1009          
   1010          void lcd_disp(u8 status)
   1011          {
   1012              switch (status) {
   1013              case MENU_BT:
   1014                  disp_clear();
   1015                  disp_draw(RES_MAIN_BT2_BMP, 48, 2);
   1016                  disp_menu(STR_MAIN_BT, 0, move_ctl.name_x, 6, ME_CENTER);
   1017                  break;
   1018              default:
   1019                  clock_show();
   1020              }
   1021          }
   1022          
   1023          //显示时与分
   1024          #pragma location="TASK_CLOCK_SEG"
   1025          void task_clock_display_hour_min(void)
   1026          {
   1027              disp_num(t_time.hour, 24, 2, DN_BIG | DN_RIGHT | DN_ZERO | 2);
   1028              disp_draw(RES_BIGNUM_COLON_BMP, 24+28+1, 2);
   1029              disp_num(t_time.minute, 24+28+1+12+1, 2, DN_BIG| DN_RIGHT | DN_ZERO | 2);
   1030          }
   1031          
   1032          //显示时钟的反选
   1033          #pragma location="TASK_CLOCK_SEG"
   1034          void task_clock_display_clock_invert(void)
   1035          {
   1036              switch (t_clock.set_sta) {
   1037              case STA_SET_TIME_YEAR:
   1038                  disp_invert(0+14, 6, 15, 2);                        //年
   1039                  break;
   1040              case STA_SET_TIME_MONTH:
   1041                  disp_invert(0+31+4+1, 6, 15, 2);                    //月
   1042                  break;
   1043              case STA_SET_TIME_DAY:
   1044                  disp_invert(0+31+4+1+16+4+1, 6, 15, 2);             //日
   1045                  break;
   1046              case STA_SET_TIME_HOUR:
   1047                  disp_invert(24, 2, 30, 3);                          //时
   1048                  break;
   1049              case STA_SET_TIME_MIN:
   1050                  disp_invert(24+28+1+12+1, 2, 30, 3);                //分
   1051                  break;
   1052              }
   1053          }
   1054          
   1055          // 将图片读到某个buff里面
   1056          #pragma location="TASK_FM_DISP"
   1057          void picture_read(u16 imageindex, char *buf)
   1058          {
   1059              u8 i;
   1060              u32 res_addr;
   1061              u8 icon_width, icon_line;                   //宽高应该都在256以内
   1062              u32 icon_addr;
   1063          
   1064              res_addr = calc_res_addr(imageindex * ICON_FILE_HEAD + 4);
   1065          
   1066              icon_width = spi_read16(res_addr);          //宽
   1067              icon_line = spi_read16(res_addr+2) >> 3;    //行
   1068              icon_addr = spi_read32(res_addr+8);         //资源起始
   1069          
   1070              icon_addr = calc_res_addr(icon_addr);
   1071          
   1072              for (i=0; i!=icon_line; i++) {
   1073                  spi_read(buf, icon_addr, icon_width);
   1074                  icon_addr += icon_width;
   1075                  buf += icon_width;
   1076              }
   1077          }
   1078          
   1079          // 关闭lcd屏幕显示
   1080          #pragma location="TASK_FM_DISP"
   1081          void lcd_off(void)
   1082          {
   1083              lcd_send_cmd(0xae);     // display off
   1084              LCD_BACKLIGHT_OFF();
   1085          }
   1086          
   1087          // 重新打开lcd屏幕显示
   1088          #pragma location="TASK_FM_DISP"
   1089          void lcd_on(void)
   1090          {
   1091              lcd_send_cmd(0xaf);     // display on
   1092              LCD_BACKLIGHT_ON();
   1093          }
   1094          
   1095          #endif


   Segment part sizes:

     Function/Label Bytes
     -------------- -----

 
 
 0 bytes of memory

Errors: none
Warnings: none
